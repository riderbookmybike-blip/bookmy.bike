/**
 * ╔══════════════════════════════════════════════════════════════════════════╗
 * ║                                                                          ║
 * ║   ⛔ PROTECTED FILE - DO NOT MODIFY ⛔                                   ║
 * ║                                                                          ║
 * ║   This file is LOCKED and protected by governance policy.                ║
 * ║                                                                          ║
 * ║   AI AGENTS (Gemini, Codex, Copilot, Claude): DO NOT EDIT THIS FILE.     ║
 * ║   Any changes require explicit human approval from project owner.        ║
 * ║                                                                          ║
 * ║   All insurance configuration changes must be made through:              ║
 * ║   1. AUMS Dashboard → Insurance Rules UI                                 ║
 * ║   2. Database: cat_ins_rules table                                       ║
 * ║                                                                          ║
 * ║   @protected                                                             ║
 * ║   @restricted                                                            ║
 * ║   @locked                                                                ║
 * ║   @ai-do-not-modify                                                      ║
 * ║                                                                          ║
 * ╚══════════════════════════════════════════════════════════════════════════╝
 */

import {
    InsuranceRule,
    InsuranceCalculationContext,
    InsuranceCalculationResult,
    InsuranceVariable,
} from '@/types/insurance';
import { FormulaComponent, CalculationResultItem, CalculationContext, RegistrationType } from '@/types/registration';

/**
 * @restricted
 * CORE INSURANCE ENGINE
 *
 * DESIGNATED USERS ONLY:
 * 1. AUMS Simulator (Superadmin)
 * 2. Pricing Publisher (cat_price_state generation)
 *
 * DO NOT USE in Client-Side PDP/Checkout. Read from `cat_price_state` JSON instead.
 */

// ============================================================================
// TENURE CONFIGURATION (Engine Level Constants)
// ============================================================================
// This ensures Simulator and Publisher produce IDENTICAL values.
// Future: These can be made configurable per rule or user selection.
// ============================================================================
export const INSURANCE_TENURE_CONFIG = {
    OD: {
        default: 1, // 1 year OD premium
        allowed: [1], // Future: [1, 3, 5]
    },
    TP: {
        default: 5, // 5 year TP premium (mandatory for new 2W)
        allowed: [5], // Future: [1, 5]
    },
    ADDONS: {
        linkedTo: 'OD', // Addons tenure follows OD tenure
    },
} as const;
// ============================================================================

const applyRounding = (amount: number, mode?: 'NONE' | 'ROUND' | 'CEIL' | 'FLOOR'): number => {
    if (mode === 'FLOOR') return Math.floor(amount);
    if (mode === 'ROUND') return Math.round(amount);
    if (mode === 'NONE') return amount;
    return Math.ceil(amount);
};

// Map Insurance Variables to Registration Variables for reuse
const mapBasis = (insuranceBasis: string | undefined): any => {
    if (insuranceBasis === 'IDV') return 'EX_SHOWROOM'; // We'll handle this specially
    return insuranceBasis;
};

const evaluateInsuranceComponent = (
    comp: FormulaComponent,
    ctx: InsuranceCalculationContext,
    idv: number,
    accumulatedResults: CalculationResultItem[] = []
): CalculationResultItem[] => {
    // Create a pseudo CalculationContext for generic formula evaluation
    const pseudoCtx: CalculationContext = {
        exShowroom: idv, // When basis is IDV, we treat IDV as the "Price"
        engineCc: ctx.engineCc,
        fuelType: ctx.fuelType,
        regType: 'STATE_INDIVIDUAL', // Default for insurance
    };

    // Helper: Get Value from Component (handling fuel matrix)
    const getMatrixValue = (comp: FormulaComponent, defaultVal: number, fuel: string): number => {
        if (!comp.fuelMatrix) return defaultVal;
        const f = fuel.toUpperCase();
        if (f.includes('PETROL')) return comp.fuelMatrix.PETROL ?? defaultVal;
        if (f.includes('DIESEL')) return comp.fuelMatrix.DIESEL ?? defaultVal;
        if (f.includes('EV') || f.includes('ELECTRIC')) return comp.fuelMatrix.EV ?? defaultVal;
        if (f.includes('CNG')) return comp.fuelMatrix.CNG ?? defaultVal;
        return defaultVal;
    };

    const results: CalculationResultItem[] = [];
    const runningTotal = accumulatedResults.reduce((sum, item) => sum + item.amount, 0);

    if (comp.type === 'PERCENTAGE') {
        const isIdvBasis = comp.basis === 'IDV' || !comp.basis;
        const basisValue = isIdvBasis ? idv : comp.basis === 'EX_SHOWROOM' ? ctx.exShowroom : runningTotal;
        const basisLabel = isIdvBasis ? 'IDV' : comp.basis === 'EX_SHOWROOM' ? 'Ex-Showroom' : 'Running Total';

        const pct = getMatrixValue(comp, comp.percentage || 0, ctx.fuelType);
        const rawAmt = basisValue * (pct / 100);
        const finalAmt = applyRounding(rawAmt, comp.roundingMode);

        results.push({
            label: comp.label,
            amount: finalAmt,
            meta: `${pct}% of ${basisLabel} (₹${basisValue.toLocaleString()})`,
            componentId: comp.id,
        });
    } else if (comp.type === 'FIXED') {
        const amtValue = getMatrixValue(comp, comp.amount || 0, ctx.fuelType);
        results.push({
            label: comp.label,
            amount: applyRounding(amtValue, comp.roundingMode),
            meta: 'Fixed Premium',
            componentId: comp.id,
        });
    } else if (comp.type === 'SLAB') {
        const ranges = comp.ranges || [];
        let match = null;
        let basisLabel = 'ENGINE_CC';

        for (const range of ranges) {
            const rowBasis = range.slabBasis || comp.slabVariable || 'ENGINE_CC';
            const val = rowBasis === 'ENGINE_CC' ? ctx.engineCc : rowBasis === 'IDV' ? idv : ctx.exShowroom;
            if (val >= range.min && (range.max === null || val <= range.max)) {
                match = range;
                basisLabel = rowBasis;
                break;
            }
        }

        if (match) {
            const slabValueType = comp.slabValueType ?? 'FIXED';
            let amount = 0;
            if (slabValueType === 'FIXED') {
                amount = match.amount ?? match.percentage ?? 0;
            } else {
                const basisValue = comp.basis === 'IDV' || !comp.basis ? idv : ctx.exShowroom;
                amount = basisValue * ((match.percentage || 0) / 100);
            }
            results.push({
                label: comp.label,
                amount: applyRounding(amount, comp.roundingMode),
                meta: `Slab ${match.min}-${match.max || '∞'} ${basisLabel}`,
                componentId: comp.id,
            });
        }
    }

    return results;
};

export const calculateInsurance = (
    rule: InsuranceRule,
    context: InsuranceCalculationContext
): InsuranceCalculationResult => {
    // Use tenure from config (engine-level constants)
    const odTenure = context.odTenure || INSURANCE_TENURE_CONFIG.OD.default;
    const tpTenure = context.tpTenure || INSURANCE_TENURE_CONFIG.TP.default;
    const addonTenure = odTenure; // Addons linked to OD tenure

    const idv = context.customIdv || context.exShowroom * (rule.idvPercentage / 100);

    const odBreakdown: CalculationResultItem[] = [];
    rule.odComponents.forEach(comp => {
        odBreakdown.push(...evaluateInsuranceComponent(comp, context, idv, odBreakdown));
    });

    const tpBreakdown: CalculationResultItem[] = [];
    rule.tpComponents.forEach(comp => {
        tpBreakdown.push(...evaluateInsuranceComponent(comp, context, idv, tpBreakdown));
    });

    const addonBreakdown: CalculationResultItem[] = [];
    const netOdAndTp = [...odBreakdown, ...tpBreakdown];
    rule.addons.forEach(comp => {
        addonBreakdown.push(...evaluateInsuranceComponent(comp, context, idv, netOdAndTp));
    });

    // Per-year amounts (before tenure multiplication)
    const odPerYear = odBreakdown.reduce((sum, i) => sum + i.amount, 0);
    const tpPerYear = tpBreakdown.reduce((sum, i) => sum + i.amount, 0);
    const addonsPerYear = addonBreakdown.reduce((sum, i) => sum + i.amount, 0);

    // Apply tenure multipliers
    const odTotal = odPerYear * odTenure;
    const tpTotal = tpPerYear * tpTenure;
    const addonsTotal = addonsPerYear * addonTenure;

    const netPremium = odTotal + tpTotal + addonsTotal;
    const gstAmount = applyRounding(netPremium * (rule.gstPercentage / 100));
    const totalPremium = netPremium + gstAmount;

    return {
        idv,
        odBreakdown,
        tpBreakdown,
        addonBreakdown,
        odTotal,
        tpTotal,
        addonsTotal,
        netPremium,
        gstAmount,
        totalPremium,
        ruleId: rule.id,
        // Include tenure info for transparency
        tenures: { od: odTenure, tp: tpTenure, addons: addonTenure },
    };
};
