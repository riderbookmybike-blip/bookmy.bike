/**
 * ╔══════════════════════════════════════════════════════════════════════════╗
 * ║                                                                          ║
 * ║   ⛔ PROTECTED FILE - DO NOT MODIFY ⛔                                   ║
 * ║                                                                          ║
 * ║   This file is LOCKED and protected by governance policy.                ║
 * ║                                                                          ║
 * ║   AI AGENTS (Gemini, Codex, Copilot, Claude): DO NOT EDIT THIS FILE.     ║
 * ║   Any changes require explicit human approval from project owner.        ║
 * ║                                                                          ║
 * ║   This file uses:                                                        ║
 * ║   - registrationEngine.ts (SOT for RTO)                                  ║
 * ║   - insuranceEngine.ts (SOT for Insurance)                               ║
 * ║                                                                          ║
 * ║   All pricing changes must be made through AUMS Dashboard UI.            ║
 * ║                                                                          ║
 * ║   @protected                                                             ║
 * ║   @restricted                                                            ║
 * ║   @locked                                                                ║
 * ║   @ai-do-not-modify                                                      ║
 * ║                                                                          ║
 * ╚══════════════════════════════════════════════════════════════════════════╝
 */

'use server';

import { createClient } from '@/lib/supabase/server';
import { adminClient } from '@/lib/supabase/admin';
import { v4 as uuid } from 'uuid';
import { revalidateTag } from 'next/cache';
import { CACHE_TAGS, tenantTag } from '@/lib/cache/tags';
import { calculateRegistrationCharges } from '@/lib/aums/registrationEngine';
import { RegistrationRule, CalculationContext, RegistrationType } from '@/types/registration';
import { calculateInsurance as engineCalculateInsurance } from '@/lib/aums/insuranceEngine';
// NO MOCKS - Insurance rules fetched from 'insurance_rules' table
import { InsuranceRule, InsuranceCalculationContext } from '@/types/insurance';

/**
 * Published Price Architecture - Server Actions
 *
 * Handles AUMS price publishing with:
 * - Row locking to prevent concurrent updates
 * - History logging for audit trail
 * - Dealer offer auto-adjustment on price increases
 * - Batched notifications per tenant
 */

interface PublishResult {
    success: boolean;
    skuId: string;
    oldOnRoad?: number;
    newOnRoad?: number;
    delta?: number;
    dealersAdjusted?: number;
    error?: string;
}

interface PublishPricesResult {
    success: boolean;
    publishJobId: string;
    results: PublishResult[];
    totalPublished: number;
    totalDealersAdjusted: number;
    notificationsSent: number;
    errors: string[];
}

/**
 * Calculate RTO for a given ex-showroom price and state
 * Returns both legacy breakdown and new SOT JSON format
 */
interface RTOBreakdown {
    roadTax: number;
    registrationCharges: number;
    hypothecationCharges?: number;
    smartCardCharges?: number;
    userCharges?: number;
    postalCharges?: number;
    cessAmount?: number;
}

interface RTOTypeBreakdown extends RTOBreakdown {
    total: number;
    cessRate?: number;
}

interface RTOJSON {
    STATE: RTOTypeBreakdown;
    BH: RTOTypeBreakdown;
    COMPANY: RTOTypeBreakdown;
    default: 'STATE';
}

interface RTOResult {
    total: number;
    breakdown: RTOBreakdown;
    json: RTOJSON;
}

/**
 * Calculate RTO using SHARED Registration Engine (SOT)
 * This ensures Simulator and Publisher produce IDENTICAL values.
 *
 * NO DUPLICATE LOGIC - Single source of truth: registrationEngine.ts
 */
async function calculateRTO(
    exShowroom: number,
    stateCode: string,
    engineCC: number = 110,
    fuelType: string = 'PETROL'
): Promise<RTOResult> {
    const supabase = adminClient;

    // Fetch the active rule for this state
    const { data: rules } = await supabase
        .from('cat_reg_rules')
        .select('*')
        .eq('state_code', stateCode)
        .eq('status', 'ACTIVE')
        .limit(1)
        .single();

    // Helper to map DB rule to frontend RegistrationRule type
    const mapDbToRule = (dbRule: any): RegistrationRule | null => {
        if (!dbRule) return null;
        return {
            id: dbRule.id,
            ruleName: dbRule.rule_name || 'Default Rule',
            stateCode: dbRule.state_code,
            vehicleType: dbRule.vehicle_type || '2W',
            effectiveFrom: dbRule.effective_from || new Date().toISOString(),
            status: dbRule.status || 'ACTIVE',
            stateTenure: dbRule.state_tenure || 15,
            bhTenure: dbRule.bh_tenure || 2,
            companyMultiplier: dbRule.company_multiplier || 2,
            components: dbRule.components || [],
            version: dbRule.version || 1,
            lastUpdated: dbRule.updated_at || new Date().toISOString(),
        };
    };

    const rule = mapDbToRule(rules);

    // Helper to calculate using shared engine
    const calculateWithEngine = (regType: RegistrationType): RTOTypeBreakdown => {
        if (!rule) {
            // Fallback if no rule exists
            const fallbackRate = regType === 'STATE_INDIVIDUAL' ? 0.11 : regType === 'BH_SERIES' ? 0.08 : 0.22;
            const roadTax = Math.round(exShowroom * fallbackRate);
            return {
                total: roadTax + 300 + 200 + 70,
                roadTax,
                registrationCharges: 300,
                smartCardCharges: 200,
                postalCharges: 70,
            };
        }

        // Use SHARED engine - pass rule's config
        const context: CalculationContext = {
            exShowroom,
            engineCc: engineCC,
            fuelType: fuelType,
            regType,
            variantConfig: {
                stateTenure: rule.stateTenure,
                bhTenure: rule.bhTenure,
                companyMultiplier: rule.companyMultiplier,
            },
        };

        const result = calculateRegistrationCharges(rule, context);

        // Extract breakdown totals
        let roadTax = 0;
        let cessAmount = 0;
        let cessRate = 0;
        let registrationCharges = 300;
        let smartCardCharges = 200;
        let postalCharges = 70;

        for (const item of result.breakdown) {
            if (item.label.toLowerCase().includes('tax') && !item.label.toLowerCase().includes('cess')) {
                roadTax += item.amount;
            } else if (item.label.toLowerCase().includes('cess')) {
                cessAmount += item.amount;
                const meta = String(item.meta || '');
                const match = meta.match(/([0-9]+(?:\.[0-9]+)?)%\s*Surcharge/i);
                if (match) {
                    cessRate = Number(match[1]);
                }
            } else if (item.label.toLowerCase().includes('registration')) {
                registrationCharges = item.amount;
            } else if (item.label.toLowerCase().includes('smart')) {
                smartCardCharges = item.amount;
            } else if (item.label.toLowerCase().includes('postal')) {
                postalCharges = item.amount;
            }
        }

        // Fallback: if meta parsing fails, derive cess % from road-tax base.
        if (!cessRate && roadTax > 0 && cessAmount > 0) {
            cessRate = (cessAmount * 100) / roadTax;
        }

        return {
            total: result.totalAmount,
            roadTax: roadTax + cessAmount,
            registrationCharges,
            smartCardCharges,
            postalCharges,
            cessAmount,
            cessRate,
        };
    };

    // Calculate for all registration types using SAME engine
    const stateBreakdown = calculateWithEngine('STATE_INDIVIDUAL');
    const bhBreakdown = calculateWithEngine('BH_SERIES');
    const companyBreakdown = calculateWithEngine('COMPANY');

    return {
        total: stateBreakdown.total,
        breakdown: stateBreakdown, // Legacy support
        json: {
            STATE: stateBreakdown,
            BH: bhBreakdown,
            COMPANY: companyBreakdown,
            default: 'STATE',
        },
    };
}

/**
 * Insurance breakdown (legacy format)
 */
interface InsuranceBreakdown {
    odPremium: number;
    tpPremium: number;
    addons?: {
        zeroDep?: number;
        [key: string]: number | undefined;
    };
    gst?: number;
}

/**
 * Insurance addon in SOT format
 */
interface InsuranceAddonJSON {
    id: string;
    label: string;
    price: number;
    gst: number;
    total: number;
    default: boolean;
}

/**
 * Insurance component with GST breakdown
 */
interface InsuranceComponentJSON {
    base: number; // Premium without GST
    gst: number; // GST amount
    total: number; // base + gst
}

/**
 * Insurance SOT JSON format
 */
interface InsuranceJSON {
    od: InsuranceComponentJSON;
    tp: InsuranceComponentJSON;
    gst_rate: number;
    net_premium: number; // OD base + TP base (before GST)
    gst: number; // Total GST on OD + TP
    base_total: number; // net_premium + gst
    pa: number; // Personal Accident cover base premium (pre-GST)
    addons: InsuranceAddonJSON[];
}

interface InsuranceResult {
    total: number;
    breakdown: InsuranceBreakdown;
    json: InsuranceJSON;
}

/**
 * Calculate Insurance with granular breakdown + SOT JSON
 */
/**
 * Calculate Insurance with granular breakdown + SOT JSON
 * Uses Shared Engine + Mock Rules (until DB table exists)
 */
async function calculateInsurance(
    exShowroom: number,
    brandId: string,
    stateCode: string,
    engineCC: number = 110,
    gstRatePercent: number = 18
): Promise<InsuranceResult> {
    // 1. Get Rule from Database (NO MOCKS)
    const supabase = adminClient;
    const { data: dbRules, error } = await supabase
        .from('cat_ins_rules')
        .select('*')
        .or(`state_code.eq.${stateCode},state_code.eq.ALL`)
        .eq('status', 'ACTIVE')
        .order('state_code', { ascending: false }) // Prefer state-specific over ALL
        .limit(1);

    if (error || !dbRules || dbRules.length === 0) {
        throw new Error(`No insurance rule found for state ${stateCode}. Please create one in AUMS Insurance Rules.`);
    }

    // Map DB columns to engine InsuranceRule type
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const dbRule = dbRules[0] as any;
    const rule: InsuranceRule = {
        id: dbRule.id,
        displayId: dbRule.display_id || dbRule.id.slice(0, 8).toUpperCase(),
        ruleName: dbRule.rule_name || `${stateCode} Rule`,
        stateCode: dbRule.state_code,
        insurerName: dbRule.insurer_name,
        vehicleType: dbRule.vehicle_type || 'TWO_WHEELER',
        effectiveFrom: dbRule.effective_from || dbRule.created_at?.split('T')[0],
        status: dbRule.status,
        idvPercentage: Number(dbRule.idv_percentage) || 95,
        gstPercentage: Number(dbRule.gst_percentage) || 18,
        version: dbRule.version || 1,
        lastUpdated: dbRule.updated_at || new Date().toISOString(),
        odComponents: dbRule.od_components || [],
        tpComponents: dbRule.tp_components || [],
        addons: dbRule.addons || [],
    };

    // 2. Create Engine Context
    // Defaults: New Vehicle, 1 Yr OD, 5 Yr TP (Standard for 2-wheelers)
    const ctx: InsuranceCalculationContext = {
        exShowroom,
        engineCc: engineCC,
        fuelType: 'PETROL',
        isNewVehicle: true,
        odTenure: 1,
        tpTenure: 5,
        customIdv: undefined, // Let engine calculate IDV (95%)
    };

    // 3. Run Shared Engine
    const result = engineCalculateInsurance(rule, ctx);

    // 4. Map Engine Result to Legacy/JSON Schema

    // Map Addons
    const addons: InsuranceAddonJSON[] = result.addonBreakdown.map(a => {
        // Simple heuristic for GST split since engine returns gross amount in breakdown generally?
        // Checking engine: evaluateInsuranceComponent returns 'amount' which is fully calculated but might not split GST explicitly per item in the array item itself.
        // ACTUALLY: The engine's `addonBreakdown` items are pre-GST usually?
        // Let's check `evaluateInsuranceComponent`: it returns `amount` = basis * pct.
        // Then `calculateInsurance` sums them up and adds GST at the end on the NET premium.
        // So `amount` here is Base Price.

        const basePrice = a.amount;
        const gst = Math.round(basePrice * (rule.gstPercentage / 100));

        // Infer ID from 'componentId' or 'label'
        const id = a.componentId || a.label.toLowerCase().replace(/\s+/g, '_');

        return {
            id,
            label: a.label,
            price: basePrice,
            gst,
            total: basePrice + gst,
            default: false, // Engine doesn't track 'default' selection state, assuming all in rule are applicable?
            // For Mock Rules, usually core addons are optional.
            // For SOT Snapshots, if it's in the list, it's available.
        };
    });

    // Map Legacy Breakdown
    const breakdown: InsuranceBreakdown = {
        odPremium: result.odTotal,
        tpPremium: result.tpTotal,
        addons: {
            // Legacy supported only one 'zeroDep' field usually
            zeroDep: addons.find(a => a.id.includes('zero') || a.label.toLowerCase().includes('zero'))?.price,
        },
        gst: result.gstAmount,
    };

    return {
        total: result.totalPremium,
        breakdown,
        json: {
            // OD with GST breakdown (base + gst = total)
            od: {
                base: result.odTotal,
                gst: Math.round(result.odTotal * (rule.gstPercentage / 100)),
                total: result.odTotal + Math.round(result.odTotal * (rule.gstPercentage / 100)),
            },
            // TP with GST breakdown (base + gst = total)
            tp: {
                base: result.tpTotal,
                gst: Math.round(result.tpTotal * (rule.gstPercentage / 100)),
                total: result.tpTotal + Math.round(result.tpTotal * (rule.gstPercentage / 100)),
            },
            gst_rate: rule.gstPercentage,
            // net_premium = OD base + TP base (before GST)
            net_premium: result.odTotal + result.tpTotal,
            // gst = total GST on OD + TP
            gst: Math.round((result.odTotal + result.tpTotal) * (rule.gstPercentage / 100)),
            // base_total = net_premium + gst
            base_total:
                result.odTotal +
                result.tpTotal +
                Math.round((result.odTotal + result.tpTotal) * (rule.gstPercentage / 100)),
            // pa = Personal Accident cover base premium (from addons)
            pa:
                addons.find(a => a.id.includes('pa') || a.label.toLowerCase().includes('personal accident'))?.price ||
                0,
            addons,
        },
    };
}

/**
 * Publish prices for multiple SKUs with full safety guarantees
 */
export async function publishPrices(skuIds: string[], stateCode: string): Promise<PublishPricesResult> {
    const supabase = await createClient();
    const publishJobId = uuid();

    // Get current user
    const {
        data: { user },
    } = await supabase.auth.getUser();
    if (!user) {
        return {
            success: false,
            publishJobId,
            results: [],
            totalPublished: 0,
            totalDealersAdjusted: 0,
            notificationsSent: 0,
            errors: ['Not authenticated'],
        };
    }

    const results: PublishResult[] = [];
    const affectedTenants = new Set<string>();
    let totalDealersAdjusted = 0;
    const errors: string[] = [];

    for (const skuId of skuIds) {
        try {
            // ... (rest of the SKU processing loop remains unchanged)
            // 1. Get SKU details for calculation (using adminClient)
            const { data: sku } = await adminClient
                .from('cat_skus')
                .select(
                    `
          id,
          price_base,
          model:cat_models!model_id(
            id,
            brand_id,
            engine_cc,
            fuel_type,
            item_tax_rate,
            hsn_code
          )
        `
                )
                .eq('id', skuId)
                .single();

            if (!sku) {
                errors.push(`SKU not found: ${skuId}`);
                continue;
            }

            const brandId = (sku as any)?.model?.brand_id;
            const engineCC = (sku as any)?.model?.engine_cc || 110;

            // 2. Get current ex-showroom from primary state table (MH canonical)
            const priceTable =
                stateCode.toUpperCase() === 'MH' ? 'cat_price_state_mh' : `cat_price_${stateCode.toLowerCase()}`;
            const { data: priceRow } = await (adminClient as any)
                .from(priceTable)
                .select('id, ex_showroom, on_road_price, is_popular, gst_rate, hsn_code')
                .eq('sku_id', skuId)
                .eq('state_code', stateCode)
                .single();

            let exShowroom: number = Number(priceRow?.ex_showroom || 0);

            if (exShowroom === 0) {
                // Fallback: Fetch latest price from cat_skus table (V2 SOT)
                const { data: skuWithPrice } = await adminClient
                    .from('cat_skus')
                    .select('price_base')
                    .eq('id', skuId)
                    .single();

                exShowroom = Number(skuWithPrice?.price_base || 0);

                if (exShowroom === 0) {
                    const errorMsg = `No price_base found for SKU ${skuId} (checked pricing table and cat_skus)`;
                    console.warn(`[Pricing Engine] Skipping ${skuId}: ${errorMsg}`);
                    results.push({
                        success: false,
                        skuId,
                        error: errorMsg,
                    });
                    continue;
                }
            }

            // 3. Calculate RTO and Insurance with granular breakdowns
            // GST + HSN source of truth: cat_models (fallback only if missing)
            const modelGstRate = Number((sku as any)?.model?.item_tax_rate);
            const gstRatePercent =
                Number.isFinite(modelGstRate) && modelGstRate > 0
                    ? modelGstRate
                    : Number(priceRow?.gst_rate || (Number(engineCC) > 350 ? 40 : 18));
            const modelHsnCode = String((sku as any)?.model?.hsn_code || '').trim();
            const fuelType = (sku as any)?.model?.fuel_type || 'PETROL';

            const rtoResult = await calculateRTO(exShowroom, stateCode, engineCC, fuelType);
            const insuranceResult = await calculateInsurance(exShowroom, brandId, stateCode, engineCC, gstRatePercent);

            const round2 = (n: number) => Math.round((Number(n) + Number.EPSILON) * 100) / 100;
            const exShowroomTotal = round2(exShowroom);
            const exShowroomBasic = round2(exShowroomTotal / (1 + gstRatePercent / 100));
            const exShowroomGstAmount = round2(exShowroomTotal - exShowroomBasic);
            const paAddon = (insuranceResult.json.addons || []).find(
                addon =>
                    String(addon?.id || '')
                        .toLowerCase()
                        .includes('pa') ||
                    String(addon?.label || '')
                        .toLowerCase()
                        .includes('personal accident')
            );
            const paBaseAmount = round2(Number(paAddon?.price ?? insuranceResult.json.pa ?? 0));
            const paGstAmount = round2(
                Number(paAddon?.gst ?? (paBaseAmount * Number(insuranceResult.json.gst_rate || 0)) / 100)
            );
            const paTotalAmount = round2(Number(paAddon?.total ?? paBaseAmount + paGstAmount));

            const stateCess = Number(rtoResult.json.STATE.cessAmount || 0);
            const bhCess = Number(rtoResult.json.BH.cessAmount || 0);
            const companyCess = Number(rtoResult.json.COMPANY.cessAmount || 0);
            const stateRegistration = Number(rtoResult.json.STATE.registrationCharges || 0);
            const bhRegistration = Number(rtoResult.json.BH.registrationCharges || 0);
            const companyRegistration = Number(rtoResult.json.COMPANY.registrationCharges || 0);

            // RoadTax in publisher JSON can include cess in some flows; split defensively.
            const stateTax = Math.max(0, Number(rtoResult.json.STATE.roadTax || 0) - stateCess);
            const bhTax = Math.max(0, Number(rtoResult.json.BH.roadTax || 0) - bhCess);
            const companyTax = Math.max(0, Number(rtoResult.json.COMPANY.roadTax || 0) - companyCess);

            const taxRate = (taxAmount: number) =>
                exShowroomTotal > 0 ? round2((taxAmount * 100) / exShowroomTotal) : 0;

            // Calculate new on-road price using STATE RTO and base insurance
            const newOnRoad = exShowroom + rtoResult.json.STATE.total + insuranceResult.json.base_total;

            // 4. Get the old on-road price for delta calculation
            const oldOnRoad = priceRow?.on_road_price || exShowroom;
            const delta = newOnRoad - oldOnRoad;

            // 5. priceColumn already set above for the state-specific column

            // 6. SOT: Save to dedicated state-level table with flat columns
            const { error: priceError } = await (adminClient as any).from(priceTable).upsert(
                {
                    id: priceRow?.id || uuid(),
                    sku_id: skuId,
                    state_code: stateCode,
                    ex_showroom: exShowroom,
                    ex_factory: exShowroomBasic,
                    ex_factory_gst_amount: exShowroomGstAmount,
                    logistics_charges: 0,
                    logistics_charges_gst_amount: 0,
                    gst_rate: Number(gstRatePercent),
                    hsn_code: modelHsnCode || priceRow?.hsn_code || null,
                    on_road_price: newOnRoad,
                    // RTO (normalized naming)
                    rto_default_type: rtoResult.json.default,
                    rto_smartcard_charges_state: Number(rtoResult.json.STATE.smartCardCharges || 0),
                    rto_smartcard_charges_bh: Number(rtoResult.json.BH.smartCardCharges || 0),
                    rto_smartcard_charges_company: Number(rtoResult.json.COMPANY.smartCardCharges || 0),
                    rto_postal_charges_state: Number(rtoResult.json.STATE.postalCharges || 0),
                    rto_postal_charges_bh: Number(rtoResult.json.BH.postalCharges || 0),
                    rto_postal_charges_company: Number(rtoResult.json.COMPANY.postalCharges || 0),
                    rto_registration_fee_state: Number(stateRegistration),
                    rto_registration_fee_bh: Number(bhRegistration),
                    rto_registration_fee_company: Number(companyRegistration),
                    rto_roadtax_rate_state: taxRate(stateTax),
                    rto_roadtax_rate_bh: taxRate(bhTax),
                    rto_roadtax_rate_company: taxRate(companyTax),
                    rto_roadtax_amount_state: Number(stateTax),
                    rto_roadtax_amount_bh: Number(bhTax),
                    rto_roadtax_amount_company: Number(companyTax),
                    rto_roadtax_cess_rate_state: Number(rtoResult.json.STATE.cessRate || 0),
                    rto_roadtax_cess_rate_bh: Number(rtoResult.json.BH.cessRate || 0),
                    rto_roadtax_cess_rate_company: Number(rtoResult.json.COMPANY.cessRate || 0),
                    rto_roadtax_cess_amount_state: stateCess,
                    rto_roadtax_cess_amount_bh: bhCess,
                    rto_roadtax_cess_amount_company: companyCess,
                    rto_total_state: Number(rtoResult.json.STATE.total || 0),
                    rto_total_bh: Number(rtoResult.json.BH.total || 0),
                    rto_total_company: Number(rtoResult.json.COMPANY.total || 0),
                    // Insurance
                    ins_own_damage_premium_amount: Number(insuranceResult.json.od.base),
                    ins_own_damage_gst_amount: Number(insuranceResult.json.od.gst),
                    ins_own_damage_total_amount: Number(insuranceResult.json.od.total),
                    ins_liability_only_premium_amount: Number(insuranceResult.json.tp.base),
                    ins_liability_only_gst_amount: Number(insuranceResult.json.tp.gst),
                    ins_liability_only_total_amount: Number(insuranceResult.json.tp.total),
                    ins_sum_mandatory_insurance:
                        Number(insuranceResult.json.od.base) + Number(insuranceResult.json.tp.base),
                    ins_sum_mandatory_insurance_gst_amount:
                        Number(insuranceResult.json.od.gst) + Number(insuranceResult.json.tp.gst),
                    ins_gross_premium:
                        Number(insuranceResult.json.od.base) +
                        Number(insuranceResult.json.tp.base) +
                        Number(insuranceResult.json.od.gst) +
                        Number(insuranceResult.json.tp.gst),
                    ins_gst_rate: Number(insuranceResult.json.gst_rate),
                    // Dynamic addon columns — write ALL addons from engine result
                    ...(() => {
                        const addonCols: Record<string, any> = {};
                        // Known mapping: addon label/id → DB column base key
                        const ADDON_COLUMN_MAP: Record<string, string> = {
                            personal_accident_cover: 'personal_accident_cover',
                            personal_accident_pa_cover: 'personal_accident_cover',
                            'personal_accident_(pa)_cover': 'personal_accident_cover',
                            pa_cover: 'personal_accident_cover',
                            pa: 'personal_accident_cover',
                            zero_depreciation: 'zero_depreciation',
                            return_to_invoice_rti: 'return_to_invoice',
                            'return_to_invoice_(rti)': 'return_to_invoice',
                            return_to_invoice: 'return_to_invoice',
                            rti: 'return_to_invoice',
                            consumables_cover: 'consumables_cover',
                            consumables: 'consumables_cover',
                            engine_protection: 'engine_protector',
                            engine_protector: 'engine_protector',
                            roadside_assistance_rsa: 'roadside_assistance',
                            'roadside_assistance_(rsa)': 'roadside_assistance',
                            roadside_assistance: 'roadside_assistance',
                            rsa: 'roadside_assistance',
                            key_protect: 'key_protect',
                            tyre_protect: 'tyre_protect',
                            pillion_cover: 'pillion_cover',
                        };
                        for (const addon of insuranceResult.json.addons || []) {
                            const rawKey = String(addon.label || addon.id || '')
                                .toLowerCase()
                                .replace(/[^a-z0-9_]+/g, '_')
                                .replace(/^_|_$/g, '');
                            const isUuidLikeRawKey =
                                /^[0-9a-f]{8}_[0-9a-f]{4}_[0-9a-f]{4}_[0-9a-f]{4}_[0-9a-f]{12}$/.test(rawKey);
                            if (isUuidLikeRawKey) continue;
                            const colKey = ADDON_COLUMN_MAP[rawKey] || rawKey;
                            if (!colKey) continue;
                            addonCols[`addon_${colKey}_amount`] = round2(addon.price || 0);
                            addonCols[`addon_${colKey}_gst_amount`] = round2(addon.gst || 0);
                            addonCols[`addon_${colKey}_total_amount`] = round2(addon.total || 0);
                            addonCols[`addon_${colKey}_default`] = addon.default ?? false;
                        }
                        return addonCols;
                    })(),
                    // Status & Audit
                    publish_stage: 'PUBLISHED',
                    is_popular: priceRow?.is_popular ?? false,
                    published_at: new Date().toISOString(),
                    published_by: user?.id || '00000000-0000-0000-0000-000000000000',
                    updated_at: new Date().toISOString(),
                },
                { onConflict: 'sku_id,state_code' }
            );

            if (priceError) {
                errors.push(`Publish failed for ${skuId} (${priceTable}): ${priceError.message}`);
                continue;
            }

            // NOTE: Legacy linear sync is removed here; canonical source is column-based pricing tables.

            // 6. Auto-adjust dealer offers if price increased
            let dealersAdjusted = 0;
            if (delta > 0) {
                // Find dealers whose margins would go negative
                const { data: affectedOffers } = await supabase
                    .from('cat_price_dealer')
                    .select('id, offer_amount, tenant_id')
                    .eq('vehicle_color_id', skuId)
                    .eq('state_code', stateCode)
                    .lt('offer_amount', 0); // Only discounts can go negative

                for (const offer of affectedOffers || []) {
                    // Adjust offer to maintain margin
                    const adjustedOffer = Math.min(((offer as any).offer_amount ?? 0) + delta, 0);
                    await (supabase as any)
                        .from('cat_price_dealer')
                        .update({ offer_amount: adjustedOffer })
                        .eq('id', (offer as any).id);
                    dealersAdjusted++;
                    affectedTenants.add((offer as any).tenant_id);
                }
            }

            results.push({
                success: true,
                skuId,
                oldOnRoad,
                newOnRoad,
                delta,
                dealersAdjusted,
            });

            totalDealersAdjusted += dealersAdjusted;
        } catch (err) {
            errors.push(`Error processing ${skuId}: ${String(err)}`);
        }
    }

    // Push Invalidation: Global Catalog
    if (results.some(r => r.success)) {
        revalidateTag(CACHE_TAGS.catalog_global, 'max');
    }

    // Push Invalidation: Affected Tenants
    for (const tenantId of affectedTenants) {
        revalidateTag(tenantTag(tenantId), 'max');
    }

    // 6. Send batched notifications per tenant
    let notificationsSent = 0;
    for (const tenantId of affectedTenants) {
        try {
            await supabase.from('notifications').insert({
                tenant_id: tenantId,
                title: 'AUMS Price Update',
                message: `On-road prices updated for ${results.length} SKU(s) in ${stateCode}. Your offers have been auto-adjusted to maintain margins. Review in Pricing Dashboard.`,
                type: 'PRICE_CHANGE',
                metadata: {
                    publish_job_id: publishJobId,
                    sku_count: results.length,
                    state_code: stateCode,
                    total_adjusted: totalDealersAdjusted,
                },
            });
            notificationsSent++;
        } catch (err) {
            errors.push(`Notification failed for tenant ${tenantId}`);
        }
    }

    return {
        success: errors.length === 0,
        publishJobId,
        results,
        totalPublished: results.filter(r => r.success).length,
        totalDealersAdjusted,
        notificationsSent,
        errors,
    };
}

/**
 * Preview calculated prices without publishing
 */
export async function previewPrices(skuIds: string[], stateCode: string) {
    const supabase = await createClient();
    const previews = [];

    for (const skuId of skuIds) {
        const { data: sku } = await supabase
            .from('cat_skus')
            .select(
                `
        id, name,
        model:cat_models!model_id(id, brand_id, engine_cc)
      `
            )
            .eq('id', skuId)
            .single();

        if (!sku) continue;

        const previewPriceTable =
            stateCode.toUpperCase() === 'MH' ? 'cat_price_state_mh' : `cat_price_${stateCode.toLowerCase()}`;
        const { data: priceRow, error: priceError } = await (supabase as any)
            .from(previewPriceTable)
            .select('ex_showroom, on_road_price, rto_total_state, ins_gross_premium')
            .eq('sku_id', skuId)
            .eq('state_code', stateCode)
            .single();

        const price = priceRow
            ? {
                  ex_showroom_price: Number(priceRow.ex_showroom) || 0,
                  on_road_price: Number(priceRow.on_road_price) || 0,
                  rto_total: Number(priceRow.rto_total_state) || 0,
                  insurance_total: Number(priceRow.ins_gross_premium) || 0,
              }
            : null;

        if (priceError || !price) continue;

        const brandId = (sku as any)?.model?.brand_id;
        const engineCC = (sku as any)?.model?.engine_cc || 110;

        const rtoResult = await calculateRTO(price.ex_showroom_price, stateCode, engineCC);
        const insuranceResult = await calculateInsurance(price.ex_showroom_price, brandId, stateCode, engineCC);
        const calculatedOnRoad = price.ex_showroom_price + rtoResult.total + insuranceResult.total;

        previews.push({
            skuId,
            name: sku.name,
            exShowroom: price.ex_showroom_price,
            current: {
                rto: price.rto_total,
                insurance: price.insurance_total,
                onRoad: price.on_road_price,
            },
            calculated: {
                rto: rtoResult.total,
                insurance: insuranceResult.total,
                onRoad: calculatedOnRoad,
            },
            delta: calculatedOnRoad - (price.on_road_price || price.ex_showroom_price),
        });
    }

    return previews;
}
