/**
 * ╔══════════════════════════════════════════════════════════════════════════╗
 * ║                                                                          ║
 * ║   ⛔ PROTECTED FILE - DO NOT MODIFY ⛔                                   ║
 * ║                                                                          ║
 * ║   This file is LOCKED and protected by governance policy.                ║
 * ║                                                                          ║
 * ║   AI AGENTS (Gemini, Codex, Copilot, Claude): DO NOT EDIT THIS FILE.     ║
 * ║   Any changes require explicit human approval from project owner.        ║
 * ║                                                                          ║
 * ║   This file uses:                                                        ║
 * ║   - registrationEngine.ts (SOT for RTO)                                  ║
 * ║   - insuranceEngine.ts (SOT for Insurance)                               ║
 * ║                                                                          ║
 * ║   All pricing changes must be made through AUMS Dashboard UI.            ║
 * ║                                                                          ║
 * ║   @protected                                                             ║
 * ║   @restricted                                                            ║
 * ║   @locked                                                                ║
 * ║   @ai-do-not-modify                                                      ║
 * ║                                                                          ║
 * ╚══════════════════════════════════════════════════════════════════════════╝
 */

'use server';

import { createClient } from '@/lib/supabase/server';
import { adminClient } from '@/lib/supabase/admin';
import { v4 as uuid } from 'uuid';
import { revalidateTag } from 'next/cache';
import { CACHE_TAGS, tenantTag } from '@/lib/cache/tags';
import { calculateRegistrationCharges } from '@/lib/aums/registrationEngine';
import { RegistrationRule, CalculationContext, RegistrationType } from '@/types/registration';
import { calculateInsurance as engineCalculateInsurance } from '@/lib/aums/insuranceEngine';
// NO MOCKS - Insurance rules fetched from 'insurance_rules' table
import { InsuranceRule, InsuranceCalculationContext } from '@/types/insurance';

/**
 * Published Price Architecture - Server Actions
 *
 * Handles AUMS price publishing with:
 * - Row locking to prevent concurrent updates
 * - History logging for audit trail
 * - Dealer offer auto-adjustment on price increases
 * - Batched notifications per tenant
 */

interface PublishResult {
    success: boolean;
    skuId: string;
    oldOnRoad?: number;
    newOnRoad?: number;
    delta?: number;
    dealersAdjusted?: number;
    error?: string;
}

interface PublishPricesResult {
    success: boolean;
    publishJobId: string;
    results: PublishResult[];
    totalPublished: number;
    totalDealersAdjusted: number;
    notificationsSent: number;
    errors: string[];
}

/**
 * Calculate RTO for a given ex-showroom price and state
 * Returns both legacy breakdown and new SOT JSON format
 */
interface RTOBreakdown {
    roadTax: number;
    registrationCharges: number;
    hypothecationCharges?: number;
    smartCardCharges?: number;
    userCharges?: number;
    postalCharges?: number;
    cessAmount?: number;
}

interface RTOTypeBreakdown extends RTOBreakdown {
    total: number;
}

interface RTOJSON {
    STATE: RTOTypeBreakdown;
    BH: RTOTypeBreakdown;
    COMPANY: RTOTypeBreakdown;
    default: 'STATE';
}

interface RTOResult {
    total: number;
    breakdown: RTOBreakdown;
    json: RTOJSON;
}

/**
 * Calculate RTO using SHARED Registration Engine (SOT)
 * This ensures Simulator and Publisher produce IDENTICAL values.
 *
 * NO DUPLICATE LOGIC - Single source of truth: registrationEngine.ts
 */
async function calculateRTO(
    exShowroom: number,
    stateCode: string,
    engineCC: number = 110,
    fuelType: string = 'PETROL'
): Promise<RTOResult> {
    const supabase = adminClient;

    // Fetch the active rule for this state
    const { data: rules } = await supabase
        .from('cat_reg_rules')
        .select('*')
        .eq('state_code', stateCode)
        .eq('status', 'ACTIVE')
        .limit(1)
        .single();

    // Helper to map DB rule to frontend RegistrationRule type
    const mapDbToRule = (dbRule: any): RegistrationRule | null => {
        if (!dbRule) return null;
        return {
            id: dbRule.id,
            ruleName: dbRule.rule_name || 'Default Rule',
            stateCode: dbRule.state_code,
            vehicleType: dbRule.vehicle_type || '2W',
            effectiveFrom: dbRule.effective_from || new Date().toISOString(),
            status: dbRule.status || 'ACTIVE',
            stateTenure: dbRule.state_tenure || 15,
            bhTenure: dbRule.bh_tenure || 2,
            companyMultiplier: dbRule.company_multiplier || 2,
            components: dbRule.components || [],
            version: dbRule.version || 1,
            lastUpdated: dbRule.updated_at || new Date().toISOString(),
        };
    };

    const rule = mapDbToRule(rules);

    // Helper to calculate using shared engine
    const calculateWithEngine = (regType: RegistrationType): RTOTypeBreakdown => {
        if (!rule) {
            // Fallback if no rule exists
            const fallbackRate = regType === 'STATE_INDIVIDUAL' ? 0.11 : regType === 'BH_SERIES' ? 0.08 : 0.22;
            const roadTax = Math.round(exShowroom * fallbackRate);
            return {
                total: roadTax + 300 + 200 + 70,
                roadTax,
                registrationCharges: 300,
                smartCardCharges: 200,
                postalCharges: 70,
            };
        }

        // Use SHARED engine - pass rule's config
        const context: CalculationContext = {
            exShowroom,
            engineCc: engineCC,
            fuelType: fuelType,
            regType,
            variantConfig: {
                stateTenure: rule.stateTenure,
                bhTenure: rule.bhTenure,
                companyMultiplier: rule.companyMultiplier,
            },
        };

        const result = calculateRegistrationCharges(rule, context);

        // Extract breakdown totals
        let roadTax = 0;
        let cessAmount = 0;
        let registrationCharges = 300;
        let smartCardCharges = 200;
        let postalCharges = 70;

        for (const item of result.breakdown) {
            if (item.label.toLowerCase().includes('tax') && !item.label.toLowerCase().includes('cess')) {
                roadTax += item.amount;
            } else if (item.label.toLowerCase().includes('cess')) {
                cessAmount += item.amount;
            } else if (item.label.toLowerCase().includes('registration')) {
                registrationCharges = item.amount;
            } else if (item.label.toLowerCase().includes('smart')) {
                smartCardCharges = item.amount;
            } else if (item.label.toLowerCase().includes('postal')) {
                postalCharges = item.amount;
            }
        }

        return {
            total: result.totalAmount,
            roadTax: roadTax + cessAmount,
            registrationCharges,
            smartCardCharges,
            postalCharges,
            cessAmount,
        };
    };

    // Calculate for all registration types using SAME engine
    const stateBreakdown = calculateWithEngine('STATE_INDIVIDUAL');
    const bhBreakdown = calculateWithEngine('BH_SERIES');
    const companyBreakdown = calculateWithEngine('COMPANY');

    return {
        total: stateBreakdown.total,
        breakdown: stateBreakdown, // Legacy support
        json: {
            STATE: stateBreakdown,
            BH: bhBreakdown,
            COMPANY: companyBreakdown,
            default: 'STATE',
        },
    };
}

/**
 * Insurance breakdown (legacy format)
 */
interface InsuranceBreakdown {
    odPremium: number;
    tpPremium: number;
    addons?: {
        zeroDep?: number;
        [key: string]: number | undefined;
    };
    gst?: number;
}

/**
 * Insurance addon in SOT format
 */
interface InsuranceAddonJSON {
    id: string;
    label: string;
    price: number;
    gst: number;
    total: number;
    default: boolean;
}

/**
 * Insurance component with GST breakdown
 */
interface InsuranceComponentJSON {
    base: number; // Premium without GST
    gst: number; // GST amount
    total: number; // base + gst
}

/**
 * Insurance SOT JSON format
 */
interface InsuranceJSON {
    od: InsuranceComponentJSON;
    tp: InsuranceComponentJSON;
    gst_rate: number;
    base_total: number;
    addons: InsuranceAddonJSON[];
}

interface InsuranceResult {
    total: number;
    breakdown: InsuranceBreakdown;
    json: InsuranceJSON;
}

/**
 * Calculate Insurance with granular breakdown + SOT JSON
 */
/**
 * Calculate Insurance with granular breakdown + SOT JSON
 * Uses Shared Engine + Mock Rules (until DB table exists)
 */
async function calculateInsurance(
    exShowroom: number,
    brandId: string,
    stateCode: string,
    engineCC: number = 110,
    gstRatePercent: number = 18
): Promise<InsuranceResult> {
    // 1. Get Rule from Database (NO MOCKS)
    const supabase = adminClient;
    const { data: dbRules, error } = await supabase
        .from('cat_ins_rules')
        .select('*')
        .or(`state_code.eq.${stateCode},state_code.eq.ALL`)
        .eq('status', 'ACTIVE')
        .order('state_code', { ascending: false }) // Prefer state-specific over ALL
        .limit(1);

    if (error || !dbRules || dbRules.length === 0) {
        throw new Error(`No insurance rule found for state ${stateCode}. Please create one in AUMS Insurance Rules.`);
    }

    // Map DB columns to engine InsuranceRule type
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const dbRule = dbRules[0] as any;
    const rule: InsuranceRule = {
        id: dbRule.id,
        displayId: dbRule.display_id || dbRule.id.slice(0, 8).toUpperCase(),
        ruleName: dbRule.rule_name || `${stateCode} Rule`,
        stateCode: dbRule.state_code,
        insurerName: dbRule.insurer_name,
        vehicleType: dbRule.vehicle_type || 'TWO_WHEELER',
        effectiveFrom: dbRule.effective_from || dbRule.created_at?.split('T')[0],
        status: dbRule.status,
        idvPercentage: Number(dbRule.idv_percentage) || 95,
        gstPercentage: Number(dbRule.gst_percentage) || 18,
        version: dbRule.version || 1,
        lastUpdated: dbRule.updated_at || new Date().toISOString(),
        odComponents: dbRule.od_components || [],
        tpComponents: dbRule.tp_components || [],
        addons: dbRule.addons || [],
    };

    // 2. Create Engine Context
    // Defaults: New Vehicle, 1 Yr OD, 5 Yr TP (Standard for 2-wheelers)
    const ctx: InsuranceCalculationContext = {
        exShowroom,
        engineCc: engineCC,
        fuelType: 'PETROL',
        isNewVehicle: true,
        odTenure: 1,
        tpTenure: 5,
        customIdv: undefined, // Let engine calculate IDV (95%)
    };

    // 3. Run Shared Engine
    const result = engineCalculateInsurance(rule, ctx);

    // 4. Map Engine Result to Legacy/JSON Schema

    // Map Addons
    const addons: InsuranceAddonJSON[] = result.addonBreakdown.map(a => {
        // Simple heuristic for GST split since engine returns gross amount in breakdown generally?
        // Checking engine: evaluateInsuranceComponent returns 'amount' which is fully calculated but might not split GST explicitly per item in the array item itself.
        // ACTUALLY: The engine's `addonBreakdown` items are pre-GST usually?
        // Let's check `evaluateInsuranceComponent`: it returns `amount` = basis * pct.
        // Then `calculateInsurance` sums them up and adds GST at the end on the NET premium.
        // So `amount` here is Base Price.

        const basePrice = a.amount;
        const gst = Math.round(basePrice * (rule.gstPercentage / 100));

        // Infer ID from 'componentId' or 'label'
        const id = a.componentId || a.label.toLowerCase().replace(/\s+/g, '_');

        return {
            id,
            label: a.label,
            price: basePrice,
            gst,
            total: basePrice + gst,
            default: false, // Engine doesn't track 'default' selection state, assuming all in rule are applicable?
            // For Mock Rules, usually core addons are optional.
            // For SOT Snapshots, if it's in the list, it's available.
        };
    });

    // Map Legacy Breakdown
    const breakdown: InsuranceBreakdown = {
        odPremium: result.odTotal,
        tpPremium: result.tpTotal,
        addons: {
            // Legacy supported only one 'zeroDep' field usually
            zeroDep: addons.find(a => a.id.includes('zero') || a.label.toLowerCase().includes('zero'))?.price,
        },
        gst: result.gstAmount,
    };

    return {
        total: result.totalPremium,
        breakdown,
        json: {
            // OD with GST breakdown (base + gst = total)
            od: {
                base: result.odTotal,
                gst: Math.round(result.odTotal * (rule.gstPercentage / 100)),
                total: result.odTotal + Math.round(result.odTotal * (rule.gstPercentage / 100)),
            },
            // TP with GST breakdown (base + gst = total)
            tp: {
                base: result.tpTotal,
                gst: Math.round(result.tpTotal * (rule.gstPercentage / 100)),
                total: result.tpTotal + Math.round(result.tpTotal * (rule.gstPercentage / 100)),
            },
            gst_rate: rule.gstPercentage,
            // base_total = (OD + TP) with GST included
            base_total:
                result.odTotal +
                result.tpTotal +
                Math.round((result.odTotal + result.tpTotal) * (rule.gstPercentage / 100)),
            addons,
        },
    };
}

/**
 * Publish prices for multiple SKUs with full safety guarantees
 */
export async function publishPrices(skuIds: string[], stateCode: string): Promise<PublishPricesResult> {
    const supabase = await createClient();
    const publishJobId = uuid();

    // Get current user
    const {
        data: { user },
    } = await supabase.auth.getUser();
    if (!user) {
        return {
            success: false,
            publishJobId,
            results: [],
            totalPublished: 0,
            totalDealersAdjusted: 0,
            notificationsSent: 0,
            errors: ['Not authenticated'],
        };
    }

    const results: PublishResult[] = [];
    const affectedTenants = new Set<string>();
    let totalDealersAdjusted = 0;
    const errors: string[] = [];

    for (const skuId of skuIds) {
        try {
            // ... (rest of the SKU processing loop remains unchanged)
            // 1. Get SKU details for calculation (using adminClient)
            const { data: sku } = await adminClient
                .from('cat_items')
                .select(
                    `
          id, 
          specs,
          parent:parent_id(
            specs,
            parent:parent_id(
              id,
              specs
            )
          )
        `
                )
                .eq('id', skuId)
                .single();

            if (!sku) {
                errors.push(`SKU not found: ${skuId}`);
                continue;
            }

            // Get brand ID from family (grandparent)
            const brandId = (sku.parent as any)?.parent?.id;
            const engineCC = (sku.specs as any)?.engine_cc || (sku.parent as any)?.specs?.engine_cc || 110;

            // 2. Get current ex-showroom or create record if not exists
            const { data: existingPrice } = await (adminClient as any)
                .from('cat_price_state')
                .select('ex_showroom_price, on_road_price')
                .eq('vehicle_color_id', skuId)
                .eq('state_code', stateCode)
                .eq('district', 'ALL')
                .single();

            let exShowroom: number;
            let isNewRecord = false;

            if (existingPrice) {
                // USER REQUEST: Respect existing price in cat_price_state (e.g. manual edits)
                exShowroom = existingPrice.ex_showroom_price;
            } else {
                // 2. Fallback: Fetch latest price from Source of Truth (cat_items hierarchy)
                const { data: skuWithPrice } = await (adminClient as any)
                    .from('cat_items')
                    .select('price_base, parent:parent_id(price_base, parent:parent_id(price_base))')
                    .eq('id', skuId)
                    .single();

                // Resolve base price from hierarchy: SKU -> Model -> Brand/Series
                const fetchedExShowroom =
                    skuWithPrice?.price_base ||
                    (skuWithPrice?.parent as any)?.price_base ||
                    (skuWithPrice?.parent as any)?.parent?.price_base ||
                    0;

                if (fetchedExShowroom === 0) {
                    errors.push(`No price_base found for SKU ${skuId} (checked hierarchy)`);
                    continue;
                }
                exShowroom = fetchedExShowroom;
                isNewRecord = true;
            }

            // 3. Calculate RTO and Insurance with granular breakdowns
            // Get SKU's GST rate from item_tax_rate
            const { data: skuTax } = await adminClient
                .from('cat_items')
                .select('item_tax_rate')
                .eq('id', skuId)
                .single();
            const gstRatePercent = (skuTax as any)?.item_tax_rate || 18;

            // Get fuel type from specs
            const fuelType = (sku.specs as any)?.fuel_type || (sku.parent as any)?.specs?.fuel_type || 'PETROL';

            const rtoResult = await calculateRTO(exShowroom, stateCode, engineCC, fuelType);
            const insuranceResult = await calculateInsurance(exShowroom, brandId, stateCode, engineCC, gstRatePercent);

            // Calculate new on-road price using STATE RTO and base insurance
            const newOnRoad = exShowroom + rtoResult.json.STATE.total + insuranceResult.json.base_total;

            // 4. Get the old on-road price for delta calculation
            const oldOnRoad = existingPrice?.on_road_price || exShowroom;
            const delta = newOnRoad - oldOnRoad;

            // 5. UPSERT cat_price_state with calculated values (Published SOT)
            const pricePayload = {
                vehicle_color_id: skuId,
                state_code: stateCode,
                ex_showroom_price: exShowroom,
                // Legacy columns - mirrored from JSON defaults
                // Legacy columns - mirrored from JSON defaults
                rto_total: Number(rtoResult.json.STATE.total),
                insurance_total: Number(insuranceResult.json.base_total),
                on_road_price: newOnRoad,
                // Set legacy numeric columns to null to avoid type errors with JSON objects
                rto_breakdown: null,
                insurance_breakdown: null,

                // JSONB columns - pass objects directly (Supabase handles serialization)
                rto: rtoResult.json,
                insurance: insuranceResult.json,
                gst_rate: gstRatePercent / 100, // Store as decimal (0.18 for 18%)
                published_at: new Date().toISOString(),
                published_by: user.id,
                is_active: true,
                district: 'ALL',
                publish_stage: 'PUBLISHED',
            };

            const { error: upsertError } = await adminClient.from('cat_price_state').upsert(pricePayload as any, {
                onConflict: 'vehicle_color_id,state_code,district',
            });

            if (upsertError) {
                errors.push(`Publish failed for ${skuId}: ${upsertError.message}`);
                continue;
            }

            // 6. Auto-adjust dealer offers if price increased
            let dealersAdjusted = 0;
            if (delta > 0) {
                // Find dealers whose margins would go negative
                const { data: affectedOffers } = await supabase
                    .from('cat_price_dealer')
                    .select('id, offer_amount, tenant_id')
                    .eq('vehicle_color_id', skuId)
                    .eq('state_code', stateCode)
                    .lt('offer_amount', 0); // Only discounts can go negative

                for (const offer of affectedOffers || []) {
                    // Adjust offer to maintain margin
                    const adjustedOffer = Math.min(((offer as any).offer_amount ?? 0) + delta, 0);
                    await (supabase as any)
                        .from('cat_price_dealer')
                        .update({ offer_amount: adjustedOffer })
                        .eq('id', (offer as any).id);
                    dealersAdjusted++;
                    affectedTenants.add((offer as any).tenant_id);
                }
            }

            results.push({
                success: true,
                skuId,
                oldOnRoad,
                newOnRoad,
                delta,
                dealersAdjusted,
            });

            totalDealersAdjusted += dealersAdjusted;
        } catch (err) {
            errors.push(`Error processing ${skuId}: ${String(err)}`);
        }
    }

    // Push Invalidation: Global Catalog
    if (results.some(r => r.success)) {
        (revalidateTag as any)(CACHE_TAGS.catalog_global);
    }

    // Push Invalidation: Affected Tenants
    for (const tenantId of affectedTenants) {
        (revalidateTag as any)(tenantTag(tenantId));
    }

    // 6. Send batched notifications per tenant
    let notificationsSent = 0;
    for (const tenantId of affectedTenants) {
        try {
            await (supabase as any).from('notifications').insert({
                tenant_id: tenantId,
                title: 'AUMS Price Update',
                message: `On-road prices updated for ${results.length} SKU(s) in ${stateCode}. Your offers have been auto-adjusted to maintain margins. Review in Pricing Dashboard.`,
                type: 'PRICE_CHANGE',
                metadata: {
                    publish_job_id: publishJobId,
                    sku_count: results.length,
                    state_code: stateCode,
                    total_adjusted: totalDealersAdjusted,
                },
            });
            notificationsSent++;
        } catch (err) {
            errors.push(`Notification failed for tenant ${tenantId}`);
        }
    }

    return {
        success: errors.length === 0,
        publishJobId,
        results,
        totalPublished: results.filter(r => r.success).length,
        totalDealersAdjusted,
        notificationsSent,
        errors,
    };
}

/**
 * Preview calculated prices without publishing
 */
export async function previewPrices(skuIds: string[], stateCode: string) {
    const supabase = await createClient();
    const previews = [];

    for (const skuId of skuIds) {
        const { data: sku } = await supabase
            .from('cat_items')
            .select(
                `
        id, name, specs,
        parent:parent_id(specs, parent:parent_id(id, specs))
      `
            )
            .eq('id', skuId)
            .single();

        if (!sku) continue;

        const { data: price, error: priceError } = await (supabase as any)
            .from('cat_price_state')
            .select('ex_showroom_price, on_road_price, rto_total, insurance_total')
            .eq('vehicle_color_id', skuId)
            .eq('state_code', stateCode)
            .eq('district', 'ALL')
            .single();

        if (priceError || !price) continue;

        const brandId = (sku.parent as any)?.parent?.id;
        const engineCC = (sku.specs as any)?.engine_cc || 110;

        const rtoResult = await calculateRTO(price.ex_showroom_price, stateCode, engineCC);
        const insuranceResult = await calculateInsurance(price.ex_showroom_price, brandId, stateCode, engineCC);
        const calculatedOnRoad = price.ex_showroom_price + rtoResult.total + insuranceResult.total;

        previews.push({
            skuId,
            name: sku.name,
            exShowroom: price.ex_showroom_price,
            current: {
                rto: price.rto_total,
                insurance: price.insurance_total,
                onRoad: price.on_road_price,
            },
            calculated: {
                rto: rtoResult.total,
                insurance: insuranceResult.total,
                onRoad: calculatedOnRoad,
            },
            delta: calculatedOnRoad - (price.on_road_price || price.ex_showroom_price),
        });
    }

    return previews;
}
